// SPDX-License-Identifier:GPL-3.0

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface ITestPool {
    function depositTokens(uint256 _amount) external;
    function unstakeTokens(uint256 _amount) external;
    function intervalReward() external returns (uint256);
    function interval() external returns (uint256);
    function rewards(address key) external returns (uint256);
    
}

interface IFotum {
    function distributeRewards(address _pool) external;
}

contract PoolConnector {
    string public name = "Test Pool USDC";
    string public description = "This pool provides rewards for staking your USDC.";
    uint256 public apy;
    uint256 epochDuration;
    uint256 lastTimeStamp;
    uint256 lastRewards;
    uint256 totalAmountStaked;
    uint256 totalAmountDeposited;
    address fotumAddress;
    ITestPool TestPool;
    IERC20 USDC;


    constructor(
        address _fotumAddress, 
        address _TestPool, 
        address _USDCAddress
    ) {
        fotumAddress= _fotumAddress;
        TestPool = ITestPool(_TestPool);
        USDC = IERC20(_USDCAddress);
        epochDuration = TestPool.interval();
        lastTimeStamp = block.timestamp;
        totalAmountStaked = 0;
        apy = 1e17;//TODO: calulate and update reward
    }
    address[] users;
    mapping(address => bool) isUser;
    mapping(address => uint256) userToDeposit;
    mapping(address => uint256) userToStake;
    mapping(address => uint256) userToRewards;

    modifier onlyFotum {
        require(msg.sender == fotumAddress);
        _;
    }

    /* Reverts direct native token transfers */
    fallback() external {
        revert();
    }

    function getAmountStaked(address _user) external view returns (uint256){
        return userToStake[_user];
    }


    /* Stakes amount to Pool after transfer from Fotum */
    function stake(uint256 _amount, address _user) external onlyFotum {
        USDC.transferFrom(msg.sender, address(this), _amount);
        userToDeposit[_user] += _amount;
        totalAmountDeposited += _amount;
        USDC.approve(address(TestPool), _amount);
        TestPool.depositTokens(_amount);
        if (isUser[_user] == false) {
            users.push(_user);
            isUser[_user] = true;
        }
    }

    /* Unstakes amount from Pool and transfers it back to Fotum */
    function unstake(uint256 _amount, address _user) external onlyFotum{
        require(userToStake[_user] >= _amount, "Not enough funds staked");
        userToStake[_user] -= _amount;
        totalAmountStaked -= _amount;
        TestPool.unstakeTokens(_amount);
        USDC.transfer(msg.sender, _amount);
    }

    function _updateBalancesAndDistributeRewards(uint256 _rewards) internal {
        for (
            uint256 userIndex;
            userIndex < users.length;
            userIndex++
        )
        {   
            address userAddress = users[userIndex];
            uint256 reward = _rewards * (userToStake[userAddress] / totalAmountStaked);
            userToRewards[userAddress] += reward;
            uint256 amountDeposited = userToDeposit[userAddress];
            userToDeposit[userAddress] = 0;
            userToStake[userAddress] += amountDeposited;
        }
        IFotum(fotumAddress).distributeRewards(address(this));
    }

    function checkUpkeep(bytes calldata /* checkData */) external view returns (bool upkeepNeeded, bytes memory /* performData */) {
        upkeepNeeded = (block.timestamp - lastTimeStamp >= epochDuration);
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if (block.timestamp - lastTimeStamp >= epochDuration) {    
            uint256 rewardsToDistribute =  TestPool.rewards(address(this)) - lastRewards;
            _updateBalancesAndDistributeRewards(rewardsToDistribute);
            lastRewards = TestPool.rewards(address(this));
            lastTimeStamp = block.timestamp;
        }
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }
}

// Vulnerable to high frequency direct USDC transfers
//Create a Keeper that updates rewards each time this contract receives a payout